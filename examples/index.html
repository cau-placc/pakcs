<html>
<head>
<title>Curry Examples</title>
</head>

<body bgcolor="#ffffff">
<h1>Curry: Example Programs</h1>
<p>
Here is a collection of (small) Curry programs.
References to larger applications can be found
<a href="http://www.informatik.uni-kiel.de/~curry/applications.html">here</a>.
Usually, each program contains
some example goals at the end in order to see its
intended application.
</p>
<hr />
The programs are sorted by the main language features they use
so that people interested in the various features of Curry
can look at these examples:
<ul>
<li><a href="#funprogs">Purely functional programs</a></li>
<li><a href="#logprogs">Purely logic programs</a></li>
<li><a href="#flprogs">Functional logic programs</a></li>
<li><a href="#nondetfunc">Non-deterministic Operations</a></li>
<li><a href="#passcon">Passive constraints (logic programming with coroutining)</a></li>
<li><a href="#residuation">Residuation and concurrent programming</a></li>
<li><a href="#monadicio">Input/Output (monadic I/O)</a></li>
<li><a href="#listcomp">Arithmetic sequences and list comprehensions:</a></li>
<li><a href="#modules">Modules</a></li>
<li><a href="#escher">Comparison with Escher</a></li>
</ul>
<hr />


<h3><a name="funprogs">Purely functional programs:</a></h3>
<ul>
<li> <a href="Rev.curry">rev.curry</a>:
list concatenation and naive reverse
</li>

<li> <a href="HigherOrder.curry">higher.curry</a>:
some standard higher-order functions: map and foldr
</li>

<li> <a href="quicksort.curry">quicksort.curry</a>:
functional quicksort based on filtering the smaller and larger elements
</li>

<li> <a href="qsortlet.curry">qsortlet.curry</a>:
quicksort based on splitting the unsorted list into a pair of lists
with smaller and larger elements
</li>

<li> <a href="inflists.curry">inflists.curry</a>:
functions defined on infinite lists, like fib and primes
</li>

<li> <a href="EscherHigher.curry">EscherHigher.curry</a>:
implementation of module "Higher" from the Escher report
</li>

</ul>
<hr />

<h3><a name="logprogs">Purely logic programs:</a></h3>
<ul>
<li> <a href="colormap.curry">colormap.curry</a>:
map coloring with classical generate-and-test
</li>

<li> <a href="family_rel.curry">family_rel.curry</a>:
a database for family relationships (relational style)
</li>

<li> <a href="family_con.curry">family_con.curry</a>:
a database for family relationships (constraint style)
</li>
</ul>
<hr />

<h3><a name="flprogs">Functional logic programs:</a></h3>
<ul>
<li> <a href="Nats.curry">Nats.curry</a>:
a basic example: natural numbers are represented as S-terms
and the substraction between numbers is defined by reversing
the addition
</li>

<li> <a href="family_fun.curry">family_fun.curry</a>:
a database for family relationships (functional logic style)</li>

<li> <a href="family_nd.curry">family_nd.curry</a>:
a database for family relationships (functional logic style
with non-deterministic operations)</li>

<li> <a href="horseman.curry">horseman.curry</a>:
a puzzle from equational logic programming (solving questions like
"How many men and horses have 8 heads and 20 feet?")
</li>

<li> <a href="First.curry">First.curry</a>:
lazy functional logic programming with infinite lists
</li>

<li> <a href="Last.curry">Last.curry</a>:
compute the last element of a list using a flexible append function
(i.e., inverting list concatenation)
</li>

<li> <a href="Member.curry">Member.curry</a>:
list membership defined by a single conditional rule based on
a flexible append function (i.e., inverting list concatenation)
</li>

<li> <a href="mergesort.curry">mergesort.curry</a>:
merge sort: sorting two lists by merging the sorted first
and second half of the list
</li>

<li> <a href="assembler.curry">assembler.curry</a>:
a one-pass assembler:
translation of a sequence of arbitrary jump-instructions into machine code
where logical variables are used to resolve forward jump addresses
</li>

</ul>
<hr />


<h3><a name="nondetfunc">Non-deterministic operations:</a></h3>
<ul>
<li> <a href="nondetfunc.curry">nondetfunc.curry</a>:
some "classical" examples for non-deterministic operations
like non-deterministic list insertion, permutation,
and permutation sort
</li>

<li> <a href="family_nd.curry">family_nd.curry</a>:
a database for family relationships (functional logic style
with non-deterministic operations)
</li>

<li> <a href="colormap_nd.curry">colormap_nd.curry</a>:
graph coloring with non-deterministic operations
exploiting the demand-driven search due to lazy evaluation in Curry
</li>

</ul>
<hr />


<h3><a name="passcon">Passive constraints (logic programming with coroutining):</a></h3>
<ul>
<li> <a href="colormap.curry">colormap.curry</a>:
map coloring with test-and-generate
(corresponds to logic programming with delays)
</li>

<li> <a href="digit.curry">digit.curry</a>:
small example for the use of arithmetic functions acting
as passive constraints
</li>

<li> <a href="rigidadd.curry">rigidadd.curry</a>:
small example from the POPL'97 paper for the evaluation
with residuation: the addition of natural numbers acts as
a passive constraint waiting for the instantiation of is arguments
</li>

</ul>
<hr />


<h3><a name="residuation">Residuation and concurrent programming:</a></h3>
<ul>
<li> <em>see also all examples for <a href="#passcon">passive constraints</a>
     </em></li>

<li> <a href="infresiduate.curry">infresiduate.curry</a>:
an example for a potential disadvantage of residuation [Hanus JLP'95]:
with residuation, the program has an infinite search space
but with narrowing, the search space is finite
</li>

<li> <a href="Account.curry">Account.curry</a>:
concurrent object-oriented programming: a bank account implemented
as an active object ("account server")
</li>

</ul>
<hr />


<h3><a name="monadicio">Input/Output (monadic I/O):</a></h3>
<ul>
<li> <a href="iodemo.curry">iodemo.curry</a>:
some demos of the monadic I/O concept
</li>

<li> <a href="Diamond.curry">Diamond.curry</a>:
printing a regular diamond of numbers on the standard output
(an adaptation from the Prolog programming contest at JICSLP'98 in Manchester)
</li>

</ul>
<hr />


<h3><a name="listcomp">Arithmetic sequences and list comprehensions:</a></h3>
<ul>
<li> <a href="listcomp/arithseq.curry">arithseq.curry</a>:
some simple examples for the arithmetic sequence notation
</li>

<li> <a href="listcomp/multgen.curry">multgen.curry</a>:
a few examples for list comprehensions with multiple generators
</li>

<li> <a href="listcomp/psort.curry">psort.curry</a>:
an implementation of permutation sort using list comprehensions
</li>

<li> <a href="listcomp/default.lcurry">default.lcurry</a>:
an implementation of Haskell-like default rules with list comprehensions
</li>

</ul>
<hr />


<h3><a name="modules">Modules:</a></h3>
<ul>
<li> <a href="modules/ModConc.curry">ModConc.curry</a>:
a module defining list concatenation several times to be important
by the example modules below
</li>

<li> <a href="modules/UseConc1.curry">UseConc1.curry</a>:
a module importing module <code>ModConc</code>
</li>

<li> <a href="modules/UseConc2.curry">UseConc2.curry</a>:
a module importing module <code>ModConc</code> qualified
in order to avoid name conflicts
</li>

</ul>
<hr />


<h3><a name="escher">Comparison with Escher:</a></h3>
Here are a few examples that are implementations of
programs from John Lloyd's papers on Escher.
<ul>
<li> <a href="EscherPerm.curry">EscherPerm.curry</a>:
module "Permute" from new Escher report
(computation of permutations with a concatentation and a split
function)
</li>

<li> <a href="EscherHigher.curry">EscherHigher.curry</a>:
implementation of module "Higher" from the Escher report
</li>

<li> <a href="EscherCond.curry">EscherCond.curry</a>:
module "Conditional" from the Escher report
(check membership in a list)
</li>

<li> <a href="relational.curry">relational.curry</a>:
module "Relational" from the Escher report
(computing with relations)
</li>

</ul>
<hr />

Back to <a href="http://curry-lang.org">Homepage of Curry</a>

<hr>
<address><a href="http://www.informatik.uni-kiel.de/~mh/">Michael Hanus</a></address>
</body>
</html>

